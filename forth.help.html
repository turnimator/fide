<html>
    <head>
        <title>ESP32Forth</title>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
    </head>
    <body>
<h2></h2>
 

<h2>Block File system</h2>
 

<h2>block</h2>
( n -- a ) Get a 1024 character block

<h2>block-fid</h2>
( – n ) "value

<h2>block-id</h2>
( -- n ) "value

<h2>buffer</h2>
( n -- a ) Get a 1024 byte block without regard to old contents

<h2>copy</h2>
( from to -- ) Copy contents of block 'from' to block 'to'

<h2>default-use</h2>
 "deferred word

<h2>empty-buffers</h2>
( -- ) Empty all buffers

<h2>flush</h2>
( -- ) Save and empty all buffers

<h2>list</h2>
( n -- ) List block n of 1024 characters to the display

<h2>load</h2>
( n -- ) Evaluate block n of 1024 characters as the input stream

<h2>open-blocks</h2>
( a n -- ) Open a file as the block file

<h2>save-buffers</h2>
( -- ) Save all buffers

<h2>scr</h2>
( -- adr ) Pointer to last listed block

<h2>thru</h2>
( a b -- ) Load blocks a thru b

<h2>update</h2>
( -- ) Mark the last block modified

<h2>use</h2>
"( ""name"" -- )" "Use ""name"" as the blockfile

<h2>Block File Editor</h2>
 

<h2>a</h2>
"( n ""text"" -- )" "Add (insert) a line in the current block with the words that follow in the input stream

<h2>d</h2>
( n -- ) Delete a line in the current block

<h2>e</h2>
( n -- ) Clear a line in the current block

<h2>l</h2>
( – ) List the current 1024 character block

<h2>n</h2>
( – ) Move to the next 1024 character block

<h2>p</h2>
( – ) Move to the previous 1024 character block

<h2>r</h2>
"( n ""text"" -- )" "Replace a line in the current block with the words that follow in the input stream

<h2>wipe</h2>
( -- ) Erase the 1024 character block

<h2>editor</h2>
( -- ) vocabulary name of the block file editor

<h2>Branching</h2>
 

<h2>[ELSE]</h2>
( – ) Interpret time ELSE

<h2>[IF]</h2>
( f – ) "Interpret time IF ( conditional interpretation of words that follow

<h2>[THEN]</h2>
(–) Interpret time THEN

<h1>forth</h1>
<h1>forth</h1>
<h2>DEFINED?</h2>
"( ""name"" -- xt | 0 )" "If the name that follows in the input stream is found in the dictionary

<h1>forth</h1>
<h1>forth</h1>
<h2>if</h2>
( flag – ) "Conditional structure

<h1>forth</h1>
<h1>forth</h1>
<h2>Character I/O</h2>
 

<h2>"."""</h2>
( “string” – ) display the string that follows in the input stream until a terminating “

<h2>accept</h2>
( b u1 -- b u2 ) accepts u1 characters to b. u2 returned is the actual count of characters received

<h2>char</h2>
"( ""character"" -- c )" Convert the non-space char that follows in the input stream and place it's value tos e.g. char 0 places 48 on top of the stack

<h2>cr</h2>
( -- ) "send carriage return

<h2>emit</h2>
( c – ) display the ascii character c

<h2>key</h2>
( – chr ) deferred word - reads the next character in the input stream - defaults to word serial-key

<h2>key?</h2>
( -- cnt ) "deferred word - returns cnt

<h2>ok</h2>
( -- ) display the string ok

<h2>page</h2>
( -- ) Emit 30 CR characters to the display

<h2>PARSE</h2>
"( c ""wordtoparse"" -- addr cnt )" "Parse the next word in the input stream

<h2>prompt</h2>
 send ok and <cr> to the display

<h2>space</h2>
( -- ) Emit a space character to the display

<h2>tib</h2>
( -- addr ) returns the address of the the terminal input buffer where input text string is held

<h2>type</h2>
( addr n -- ) "deferred word - display an n long character string

<h2>ip.</h2>
( n --  ) print n in IP address format e.g. 192.168.1.2

<h2>ip#</h2>
( n1 -- n2 ) print one section of an ip address

<h2>Comment</h2>
 

<h2>(</h2>
"( ""string""-- )" "Start of a 1 line comment

<h2>\</h2>
 "Start of a 1 line comment

<h2>Comparison</h2>
 

<h2><</h2>
( n1 n2 -- f ) "f=true of n1 less than n2

<h2><=</h2>
( n1 n2 -- f ) "f=true if n1 less than or equal n2

<h2><></h2>
( n1 n2 -- f ) "f=true if n1 not equal n2

<h2>=</h2>
( n1 n2 -- f ) "f=true if n1 equals n2

<h2>></h2>
( n1 n2 -- f ) "f=true if n1 greater than n2

<h2>>=</h2>
( n1 n2 -- f ) "f=true if n1 greater than or equal n2

<h2>0<</h2>
( n -- f ) "f=true if n less than zero

<h2>0<></h2>
( n -- f ) "f=true if n not equal zero

<h2>0=</h2>
( n -- f ) "f=true if n equals zero

<h2>Debug</h2>
 

<h2>.s</h2>
( – ) display the data stack depth and data stack on one line of the display

<h2>dump</h2>
( addr n – ) "display memory starting at addr

<h2>dump-file</h2>
( a n a n -- ) 

<h2>order</h2>
( – ) Print the vocabulary search order

<h2>see</h2>
"( ""text"" -- )" Attempt to decompile the word which follows in the input stream

<h2>vlist</h2>
( -- ) List the words in the context vocabulary (not chains) e.g. vlist WiFi only lists words in the Wifi vocabulary

<h2>words</h2>
( -- ) List the words in the context vocabulary (including chains)

<h2>Dictionary</h2>
 

<h2>>body</h2>
( xt -- addr ) addr is the data-field address corresponding to execution token xt

<h2>>link</h2>
( xt -- addr )  addr is the link-field address corresponding to execution token xt

<h2>>link&</h2>
( xt -- addr ) used internally  by >link

<h2>>name</h2>
( xt -- addr  n | 0 ) "convert execution token xt to a name located at addr with n characters

<h2>FIND</h2>
( addr n -- xt | 0 ) "using the counted string at addr with n characters

<h2>forget</h2>
"( ""name"" -- )" "find the word that follows in the input stream; if it exists in the current dictionary

<h2>here</h2>
( -- addr ) "returns the address of the first free location above the code dictionary

<h2>only</h2>
( -- ) "Reset context stack to one item

<h2>transfer</h2>
"( ""name"" -- )" "Move a word from its current dictionary to the current vocabulary. Useful for ""hiding"" helper words that aren't useful in normal programming"

<h2>transfer{</h2>
( -- ) Move all the words that follow in the input stream up until a terminating } to the current vocabulary. All the words must have been defined beforehand

<h2>Exceptions</h2>
 

<h2>assert</h2>
( f -- ) "if flag f=true

<h2>catch</h2>
( ca -- err# | 0 ) sets up a local error frame on the return stack and executes the word referenced by the execution word ca. It returns a non-zero error code or a zero if no error occurred

<h2>handler</h2>
( -- addr ) holds the return stack pointer for error handling - zero if no error occurred.

<h2>throw</h2>
( err# -- err# ) throws the system back to 'catch' so that the error condition can be processed. 'Catch' is backtracked by restoring the return stack from the pointer stored in 'handler' and popping the old handler and SP off the error frame on the return stack.

<h2>Files</h2>
 

<h2>BIN</h2>
( fam1 -- fam2 ) "Modify the implementation-defined file access method fam1 to additionally select a ""binary""

<h2>CLOSE-FILE</h2>
( fh -- ior ) ior= Input Output Result Close the file identified by fileid. ior is the implementation-defined I/O result code.

<h2>CREATE-FILE</h2>
( a n mode -- fh ior )  ( c-addr u fam -- fileid ior ) "Create the file named in the character string specified by c-addr and u

<h2>DELETE-FILE</h2>
( a n -- ior ) ( c-addr u -- ior ) Delete the file named in the character string specified by c-addr u. ior is the implementation-defined I/O result code.

<h2>FILE-POSITION</h2>
( fh -- n ior ) ( fileid -- ud ior ) ud is the current file position for the file identified by fileid. ior is the implementation-defined I/O result code. ud is undefined if ior is non-zero.

<h2>FILE-SIZE</h2>
( fh -- n ior ) ( fileid -- ud ior ) "ud is the size

<h2>FLUSH-FILE</h2>
( fileid -- ior ) "Attempt to force any buffered information written to the file referred to by fileid to be written to mass storage

<h2>include</h2>
"( ""name"" -- )" "Using the next word in the input stream

<h2>INCLUDED</h2>
"( a n -- ) ( i * x c-addr u -- j * x ) Typical use: ... S"" filename"" INCLUDED ... " "Remove c-addr u from the stack. Save the current input source specification

<h2>R/O</h2>
( -- mode ) read only mode - used with OPEN-FILE

<h2>R/W</h2>
( -- mode ) read write mode - used with OPEN-FILE

<h1> ior is zero and u2 is equal to u1.</h1>
<h1> ior is zero and u2 is the number of characters actually read.</h1>
<h1> ior is zero and u2 is zero.</h1>
<h2>remember</h2>
( -- ) Save a snapshot to the default file (./myforth or /spiffs/myforth on ESP32)

<h2>reset</h2>
( -- ) Reset removes the custom message

<h2>RESET </h2>
( -- )  Delete the default filename.

<h1> the portion of the file added as a result of the operation might not have been written.</h1>
<h2>restore</h2>
"( ""name"" -- )" Restore a snapshot from a file

<h2>revive</h2>
( -- ) Restore the default filename

<h2>save</h2>
"( ""name"" -- )" Saves a snapshot of the current dictionary to a file

<h2>startup:</h2>
"( ""name"" -- )" "Save a snapshot to the default file arranging for ""name"" to be run on startup SEE EXAMPLE B743"

<h2>W/O</h2>
( -- mode ) write only mode - used with OPEN-FILE

<h2>Input / Output</h2>
 

<h2>adc</h2>
( pin# -- n ) alias for analogRead - see example below

<h2>analogRead</h2>
( pin -- n ) Analog read from 0-4095

<h2>dacWrite</h2>
( pin 0-255 -- ) "Write to DAC (pin 25

<h2>digitalRead</h2>
( pin -- value ) Read GPIO state - see example below

<h2>digitalWrite</h2>
( pin value -- ) Set GPIO pin state

<h1>forth</h1>
<h1>forth</h1>
<h2>pulseIn</h2>
( pin value usec -- usec/0 ) Wait for a pulse

<h2>tone</h2>
( channel freq ) Write tone frequency

<h2>Interrupts</h2>
 

<h2>timer_isr_register</h2>
( group timer xt arg ret -- 0/err ) 

<h2>esp_intr_alloc</h2>
( source flags xt args handle* -- 0/err ) 

<h2>ESP_INTR_FLAG_DEFAULT</h2>
( -- 0 ) Default handler allows per pin routing

<h2>ESP_INTR_FLAG_EDGE</h2>
( -- 512 ) gpio_install_isr_service flag

<h2>ESP_INTR_FLAG_INTRDISABLED</h2>
( -- 2048 ) gpio_install_isr_service flag

<h2>ESP_INTR_FLAG_IRAM</h2>
( -- 1024 ) gpio_install_isr_service flag

<h2>ESP_INTR_FLAG_LEVELn</h2>
( n1 -- n2 ) "n2 = 2 to the power n1

<h2>ESP_INTR_FLAG_NMI</h2>
( -- 128 ) gpio_install_isr_service flag

<h2>ESP_INTR_FLAG_SHARED</h2>
( -- 256 ) gpio_install_isr_service flag

<h2>esp_intr_alloc</h2>
 

<h2>esp_intr_free</h2>
( handle -- 0/err ) 

<h2>gpio_config</h2>
( gpio_config_t* -- 0/err ) "GPIO common configuration. Configure GPIO’s Mode

<h2>gpio_deep_sleep_hold_dis</h2>
( -- ) Disable all digital gpio pad hold function during Deep-sleep

<h2>gpio_deep_sleep_hold_en</h2>
( -- ) "Enable all digital gpio pad hold function during Deep-sleep. When the chip is in Deep-sleep mode

<h2>gpio_get_drive_capability</h2>
( pin cap* -- 0/err ) 

<h2>gpio_get_level</h2>
( pin -- level ) GPIO get input level of 'pin'

<h2>gpio_hold_dis</h2>
( pin -- 0/err ) 

<h2>gpio_hold_en</h2>
( pin -- 0/err ) 

<h2>gpio_install_isr_service</h2>
( a -- ) "a = combination of gpio_install_isr_service flags - Install the driver’s GPIO ISR handler service

<h1>interrupts</h1>
<h1>interrupts</h1>
<h2>gpio_intr_disable</h2>
( pin -- 0/err ) Disable GPIO module interrupt signal for 'pin'

<h2>gpio_intr_enable</h2>
( pin -- 0/err ) Enable GPIO module interrupt signal for'pin'

<h2>#GPIO_INTR_HIGH_LEVEL</h2>
( -- 5 ) constant - e.g. 2 #GPIO_INTR_HIGH_LEVEL gpio_set_intr_type

<h2>#GPIO_INTR_LOW_LEVEL</h2>
( -- 4 ) constant - e.g. 2 #GPIO_INTR_LOW_LEVEL gpio_set_intr_type

<h1>interrupts</h1>
<h1>interrupts</h1>
<h2>gpio_isr_handler_add</h2>
pin xt 0 -- 0/err ) "Having already set up the interrupt type

<h1>interrupts</h1>
<h2>gpio_isr_handler_remove</h2>
( pin -- 0/err ) Remove ISR handler for the corresponding GPIO pin

<h2>gpio_pulldown_dis</h2>
( pin -- 0/err ) Disbale pull down load on 'pin'

<h2>gpio_pulldown_en</h2>
( pin -- 0/err ) Enable pull down load on 'pin'

<h2>gpio_pullup_dis</h2>
( pin -- 0/err ) Disable pull up load on 'pin'

<h2>gpio_pullup_en</h2>
( pin -- 0/err ) Enable pull up load on 'pin'

<h2>gpio_reset_pin</h2>
( pin -- 0/err ) "Reset a gpio to default state (select gpio function

<h2>gpio_set_direction</h2>
( pin mode -- 0/err ) Set gpio signal direction of 'pin'

<h2>gpio_set_drive_capability</h2>
( pin cap -- 0/err ) Set GPIO pad 'pin' drive capability or strength 'cap'

<h2>gpio_set_intr_type</h2>
( pin type -- 0/err ) "Set the required i/o pin to the interrupt type

<h2>gpio_set_level</h2>
( pin level -- 0/err ) GPIO set the output level pf 'pin' =1 or 0

<h2>gpio_set_pull_mode</h2>
( pin mode -- 0/err ) Configure GPIO 'pin' pull-up/pull-down resistors by means of 'mode'. GPIO 34-39 don't have this facility

<h2>gpio_uninstall_isr_service</h2>
( -- ) "Uninstall the driver’s GPIO ISR service

<h2>gpio_wakeup_disable</h2>
( pin -- 0/err ) Disable GPIO wake-up function on 'pin'

<h2>gpio_wakeup_enable</h2>
( pin type -- 0/err ) Enable GPIO wake-up function on 'pin' - only type #GPIO_INTR_LOW_LEVEL or #GPIO_INTR_HIGH_LEVEL can be used

<h1>interrupts</h1>
<h2>LED control - pulse width modulation</h2>
 

<h2>duty</h2>
( channel duty -- ) "like ledcWrite

<h1>forth</h1>
<h2>freq</h2>
( channel freq -- ) "like ledcSetup

<h1>forth</h1>
<h2>ledcAttachPin</h2>
( pin channel -- ) Assigns which 'channel' (0-15) of the PWM engine the 'pin' is connected to

<h2>ledcDetachPin</h2>
( pin -- ) Detaches #pin' from the pwm engine

<h2>ledcRead</h2>
( channel -- n ) Read the current dutycycle setting for 'channel'

<h2>ledcReadFreq</h2>
( channel -- freq ) "Get frequency (x 1

<h2>ledcSetup</h2>
( channel freq resolution -- freq ) Setup one of the 16 pwm channels (0-15) at frequency=freq*1000 Hz  with 'resolution'

<h2>ledcWrite</h2>
( channel duty -- ) Set 'channel'  (0-15) at 'duty' level (0-100)

<h2>ledcWriteNote</h2>
( channel note octave -- freq ) "channel 0-12

<h1>ledc</h1>
<h1>ledc</h1>
<h2>Logic</h2>
 

<h2>AND</h2>
( n1 n2 – n3 ) n3 = n1 AND n2 (bit wise)

<h2>invert</h2>
 

<h2>LSHIFT</h2>
( x1 u -- x2 ) "Perform a logical left shift of u bit-places on x1

<h2>OR</h2>
( n1 n2 – n3 ) n3 = n1 OR n2 ( bit-wise )

<h2>RSHIFT</h2>
( x1 u -- x2 ) "Perform a logical right shift of u bit-places on x1

<h2>XOR</h2>
( n1 n2 -- n3 ) n3 = n1 XOR n2 ( bit-wise)

<h2>Looping</h2>
 

<h1> then inside ?do .. loop is NOT executed</h1>
<h2>+loop</h2>
( n -- ) e.g. : +looptest 20 0 do i . 2 +loop ; results when run in 0 2 4 6 8 10 12 14 16 18 being displayed

<h2>again</h2>
( -- ) begin <forth words> again

<h1>forth</h1>
<h1>forth</h1>
<h2>EXIT</h2>
( -- ) "Return control to the calling definition. Before executing EXIT within a do-loop

<h1>forth</h1>
<h2>i</h2>
( -- n ) Place current loop index on top of stack

<h2>j</h2>
( -- n ) Place index count for next outer lop top of stack

<h2>leave</h2>
( -- ) Force do loop termination

<h2>loop</h2>
( -- ) part of do <forth words> loop construct

<h2>next</h2>
( -- ) part of for <forth words> next construct

<h2>repeat</h2>
( -- ) part of begin <forth words that leave f on the stack> while < more forth words> repeat

<h1>forth</h1>
<h2>until</h2>
( f -- ) begin <forth words that leave f on stack> until

<h2>while</h2>
( f -- ) part of begin <forth words that leave f on the stack> while < more forth words> repeat

<h2>Maths</h2>
 

<h2>-</h2>
( n1 n2 -- n3 ) n3 = n1 - n2

<h2>*</h2>
( n1 n2 -- n3 ) n3 = n1 * n2

<h2>*/</h2>
( n1 n2 n3 -- n4 ) Multiply n1 by n2 producing the intermediate double-cell result d. Divide d by n3 giving the single-cell quotient n4

<h2>*/MOD</h2>
( n1 n2 -n3 -- n4 n5 ) Multiply n1 by n2 producing the intermediate double-cell result d. Divide d by n3 producing the single-cell remainder n4 and the single-cell quotient n5

<h2>/</h2>
( n1 n2 -- n3 ) "Divide n1 by n2

<h2>/mod</h2>
( n1 n2 -- n3 n4 ) "Divide n1 by n2

<h2>+</h2>
( n1 n2 -- n3 ) n3 = n1 + n1

<h2>2*</h2>
( n1 -- n2 ) n2 = n1 * 2

<h2>2/</h2>
( n1 -- n2 ) n2 = n1 / 2

<h2>4*</h2>
( n1 -- n2 ) n2 = n1 * 4

<h2>4/</h2>
( n1 -- n2 ) n2 = n1 / 4

<h2>abs</h2>
( n1 -- n2 ) n2 is the absolute value of n1

<h2>max</h2>
( n1 n2 -- n3 ) n3 = the larger of n1 or n2

<h2>min</h2>
( n1 n2 – n3 ) n3 = the smaller of n1 or n2

<h2>mod</h2>
( n1 n2 – n3 ) "Divide n1 by n2

<h2>negate</h2>
( n – -n ) Two's complement of top of stack

<h2>U/MOD</h2>
( u1 u2 -- rem quot ) "Unsigned division

<h2>1+</h2>
( n-- n+1 ) increment value on the stack by 1 

<h2>1-</h2>
( n-- n1- ) decrement value on the stack by 1 

<h2>Memory</h2>
 

<h2>!</h2>
( n addr --> ) store x at addr

<h2>@</h2>
( addr --n ) Retrieves the integer value n stored at address addr

<h2>+!</h2>
( n addr -- ) Increments the content of a variable by the value n

<h1>forth</h1>
<h1>forth</h1>
<h2>2!</h2>
( n1 n2  addr --> ) "store n1

<h2>2@</h2>
( addr --n1 n2 ) "read n1

<h2>C!</h2>
( c addr --> ) store byte c at addr

<h2>C@</h2>
( addr --c ) read byte c from addr

<h2>allocate</h2>
( n -- a ior ) "reserve a memory chunk of n bytes

<h2>cell/</h2>
( n1 -- n2 ) n2 = n1 / 4

<h2>cell+</h2>
( n1 -- n2 ) n2 = n1 + 4

<h2>cells</h2>
( n1 -- n2 ) n2 = n1 * 4

<h2>cmove</h2>
( addr1 addr2 n -- ) "move n bytes from addr1 to addr2

<h2>cmove></h2>
( addr1 addr2 n -- ) "copy n bytes from memory starting at c-addr1 to that starting at c-addr2

<h2>fill</h2>
( addr n c ) fill memory from addr for n bytes with byte c

<h2>free</h2>
( a --  ) free memory previously reserved allocate - see also resize

<h2>L!</h2>
( n addr -- ) write n to addr in real ESP32 memory space 

<h2>L@</h2>
( addr --n ) read n from real ESP32 memory space

<h2>resize</h2>
( a n -- a ior ) "ior=true if a memory chunk reserved with MALLOC resized to n bytes correctly

<h2>Number I/O</h2>
 

<h2>?</h2>
( addr -- ) display value at addr

<h2>.</h2>
( n – ) display top of stack

<h2>#</h2>
( ud1 -- ud2 ) Convert next digit of ud1 and HOLD it

<h2>#></h2>
( ud -- addr n ) Drop ud and prepare string for TYPE

<h2>#s</h2>
( ud -- 0 0 ) Convert and HOLD all remaining significant digits

<h2><#</h2>
( --  ) Begin a formatted number conversion

<h2>base</h2>
( -- addr ) Stores the current number display base - defaults to 10 decimal

<h2>binary</h2>
( – ) Set current number base to 2 decimal

<h2>decimal</h2>
( – ) Set current number base to 10 decimal

<h2>extract</h2>
( n base -- n c ) extracts the least significant digit from a number n. n is divided by the radix in BASE and returned on the stack

<h2>hex</h2>
( – ) Set current number base to 16 decimal

<h2>hold</h2>
( c -- ) Insert character into formatted string

<h2>n.</h2>
( n -- ) "display n in decimal

<h2>octal</h2>
( -- ) Set current number base to 8 decimal

<h2>pad</h2>
( -- addr ) returns the address of the text buffer where numbers are constructed and text strings are stored temporarily

<h2>sign</h2>
(n ud -- ud ) HOLD minus sign only if n is negative

<h2>u.</h2>
( n -- ) display n in the current number base

<h2>Registers</h2>
 

<h2>m!</h2>
 

<h2>m@</h2>
 

<h2>SD card</h2>
 

<h1>SD</h1>
<h1>These words are inside the SD vocabulary. They allow use of an SDcard over SPI.</h1>
<h2>SD.begin </h2>
( -- ok ) "uses all the defaults ""/sd"" etc."

<h2>SD.beginDefaults ( -- sspin SPIClass frequency mountpointsz maxfiles format_if_empty )</h2>
 

<h2>"(    SS    SPI      4000000   ""/sd""        5        false )"</h2>
 

<h2>SD.beginFull ( sspin SPIClass frequency mountpoint maxfiles format_if_empty -- ok )</h2>
 

<h2>SD.end </h2>
( -- ) 

<h2>SD.cardType </h2>
( -- n ) 

<h2>SD.totalBytes </h2>
( -- n ) 

<h2>SD.usedBytes </h2>
( -- n ) 

<h2>SD_MMC card</h2>
 

<h2>SD_MMC.begin</h2>
( mount mode1bit ) default mode1bit=false

<h2>SD_MMC.cardType</h2>
( -- n ) 

<h2>SD_MMC.end</h2>
( -- ) 

<h2>SD_MMC.totalBytes</h2>
( -- n ) 

<h2>SD_MMC.usedBytes</h2>
( -- n ) 

<h1>Serial communication</h1>
<h2>Serial.available</h2>
( -- f ) Get the number of bytes (characters) available for reading from the serial port. This is data that’s already arrived and stored in the serial receive buffer (which holds 64 bytes)

<h2>Serial.begin</h2>
( baud -- ) Start serial port. Sets the data rate in bits per second (baud) for serial data transmission

<h2>Serial.end</h2>
( -- ) "Disables serial communication

<h2>Serial.flush</h2>
( -- ) Waits for the transmission of outgoing serial data to complete

<h2>Serial.readBytes</h2>
( a length -- n ) "Serial.readBytes reads characters from the serial port into a buffer

<h2>Serial.write</h2>
( a n -- n ) Writes n bytes of data to the serial port from buffer at address a

<h2>Sockets</h2>
 

<h2>accept</h2>
( addr length-- f ) 

<h2>AF_INET</h2>
( -- 2) constant

<h2>bind</h2>
( addr -- f ) 

<h2>connect</h2>
( addr -- f ) 

<h2>errno</h2>
( -- f ) f = the error number of the last sockets action

<h2>listen</h2>
( socket backlog -- f ) Listen for socket connections and limit the queue of incoming connections - 'backlog' is the max no. of connections that can be put on hold

<h2>poll</h2>
( pollfd n1 n2 -- f ) 

<h2>select</h2>
( n1 n2 n3 n4 -- f ) 

<h2>sizeof(sockaddr_in)</h2>
( -- 16 ) constant

<h2>SOCK_STREAM</h2>
( -- 1) constant

<h1>sockets</h1>
<h2>Serial Peripheral Interface Flash File System</h2>
 

<h2>SPIFFS.begin</h2>
( format-on-fail path-z max-files -- f ) "Mounts file system. It must be called before any other SPIFFS words are used. Returns true if file system was mounted successfully

<h2>SPIFFS.end</h2>
( -- ) Unmounts the flash memory file system

<h2>SPIFFS.format</h2>
( -- f ) Format the flash memory 'disk'. returns true if successful

<h2>SPIFFS.totalBytes</h2>
( -- n ) Returns the total capacity of the flash memory 'disk'

<h2>SPIFFS.usedBytes</h2>
( -- n ) Returns the total space occupied by flash memory files

<h2>Stack functions</h2>
 

<h2>-rot</h2>
( x1 x2 x3 -- x2 x3 x1) rotate 3rd cell to top

<h2>>R</h2>
( n – ) move n to the return stack

<h2>2drop</h2>
( n1 n2 – ) discard the top of stack

<h2>2dup</h2>
( n1 n2 – n1 n2 n1 n2) duplicate the top two items on the data stack

<h1>forth</h1>
<h2>DROP</h2>
( n – ) discard the top of stack

<h2>DUP</h2>
( n – n n ) duplicate the top of stack

<h2>nip</h2>
( n1 n2 -- n2 ) remove the 2nd item on the data stack

<h2>OVER</h2>
( n1 n2 -- n1 n2 n1 ) duplicate 2nd item on the data stack

<h2>R@</h2>
( -- n ) copy the top of the return stack to the top of data stack

<h2>R></h2>
( – n ) Move top of return stack to data stack

<h2>rdrop</h2>
( -- ) drop the top of the return stack

<h2>rot</h2>
( n1 n2 n3 – n2 n3 n1 ) rotate 3rd cell to top

<h2>RP!</h2>
( addr -- ) set the return stack pointer

<h2>RP@</h2>
( -- addr ) read the return stack pointer

<h2>rp0</h2>
( -- addr ) constant - the initial value of the return stack pointer at switch-on

<h2>SP!</h2>
( addr -- ) Set the data stack pointer

<h2>SP@</h2>
( -- addr ) Read the data stack pointer

<h2>sp0</h2>
( -- n ) constant - the initial value of the data stack pointer at switch-on

<h2>SWAP</h2>
( n1 n2 – n2 n1 ) swap the top two data stack entries

<h2>Streams</h2>
 

<h2>>offset</h2>
 

<h2>>read</h2>
 

<h2>>stream</h2>
 

<h2>>write</h2>
 

<h2>ch>stream</h2>
 

<h2>empty?</h2>
 

<h2>full?</h2>
 

<h2>stream</h2>
"( n ""name"" -- )" "define a stream

<h2>stream#</h2>
 

<h2>stream></h2>
 

<h2>stream>ch</h2>
 

<h2>wait-read</h2>
 

<h2>wait-write</h2>
 

<h2>String functions</h2>
 

<h1>forth</h1>
<h2>$place</h2>
( addr cnt -- ) 

<h2>"r"""</h2>
"( ""string"" -- a n )" Creates a temporary counted string

<h2>r|</h2>
( string| -- a n ) Creates a temporary counted string ending with | - see the example below that creates a stand alone program

<h2>"s"""</h2>
( -- addr cnt ) "creates a string until a terminating "". Leaves the string address addr and the character count cnt on the stack e.g. s"" Hello Bob"""

<h2>S>NUMBER?</h2>
( addr cnt -- n f=true | f=false ) "converts the counted ascii string stored at addr to number n with f=true

<h2>s>z</h2>
( a n -- z ) Convert a counted string string to null terminated string

<h2>startswith?</h2>
( addr1 n1 addr2 n2 -- f ) "f=true if string at addr1 starts with string at addr2

<h2>str</h2>
( n -- addr cnt ) convert n to a counted string

<h2>str=</h2>
( addr1 n1 addr2 n2 -- f ) "f=true if the two counted strings are equal

<h2>"z"""</h2>
"( ""string"" -- addr )" Creates a null terminated string on the heap at addr

<h2>z>s</h2>
( addr -- addr n ) Convert a null terminated string at addr to a counted string

<h2>System</h2>
 

<h2>#tib</h2>
( -- addr ) variable

<h2>>in</h2>
( -- addr ) variable

<h2>1</h2>
( -- -1 ) constant -1 left on the data stack

<h2>bl</h2>
( -- 32 ) returns the value of the SPACE char

<h2>bye</h2>
( -- ) "deferred word

<h2>CELL</h2>
( -- 4 ) returns the number of bytes per standard forth number - 32 bits

<h2>current</h2>
( -- addr ) points to a vocabulary thread to which new definitions are to be added

<h2>echo</h2>
( -- addr ) "All input stream is echoed on output stream if echo = -1

<h2>evaluate</h2>
( addr cnt -- ) "evaluate the counted string at addr

<h2>EXECUTE</h2>
( xt -- ) Execute the word whose execution token is top of stack

<h1>forth</h1>
<h2>hld</h2>
( -- adr ) holds a pointer in building a numeric output string

<h1>forth</h1>
<h2>LED</h2>
( -- 2 ) Some ESP32 modules have an LED fitted on GPIO pin 2

<h1>forth</h1>
<h2>nl</h2>
( -- 10 ) the value of the NEWLINE character

<h1>forth</h1>
<h2>quit</h2>
( -- ) "Leave stack intact

<h2>state</h2>
( -- addr ) "system variable

<h2>TERMINATE</h2>
( n -- ) Call system exit

<h2>Tasks - multitasking</h2>
 

<h2>.tasks</h2>
( -- ) List running tasks

<h2>pause</h2>
( -- ) yield to other tasks

<h2>start-task</h2>
( task -- ) Activate a task - see example below

<h2>task</h2>
"( xt dsz rsz ""name"" -- )" "Create a new task

<h2>main-task</h2>
 

<h2>task-list</h2>
 

<h2>Telnet</h2>
 

<h2>broker</h2>
( --) Deferred word - executes broker-connection by default

<h2>broker-connection</h2>
( -- ) Processing loop for the active TELNET link

<h2>client</h2>
 

<h2>client-len</h2>
( -- adr ) variable

<h2>clientfd</h2>
( -- flag ) "value

<h2>connection</h2>
 

<h2>server</h2>
( port -- ) Start telnet  server daemon on port - see example below

<h2>sockfd</h2>
( -- flag) "value

<h2>telnet-emit</h2>
( c -- ) Emit c character on the active telnet port

<h2>telnet-emit'</h2>
 

<h2>telnet-key</h2>
( -- c ) Retrieve a character c from the active telnet port

<h2>telnet-port</h2>
( a n -- ) 

<h2>telnet-type</h2>
(adr len -- ) Send a counted string on the active telnet port

<h2>Time / Timers</h2>
 

<h1>"There are two groups of two timer channels</h1>
<h2>ms</h2>
( n1 --  ) "pause for ""n"" milliseconds."

<h2>MS-TICKS</h2>
( -- n1 ) Time since start in milliseconds

<h2>alarm</h2>
( t -- a ) 

<h2>alarm-enable!</h2>
( f t -- ) Alarm enable

<h2>alarm-enable@</h2>
( t -- f ) Alarm enabled?

<h2>autoreload!</h2>
( v t -- ) 

<h2>divider!</h2>
( n t -- ) Timer divider 2 - 65535

<h2>edgeint!</h2>
( f t -- ) Edge trigger

<h2>enable!</h2>
( v t -- ) Timer enable/disable

<h2>increase!</h2>
( v t -- ) Timer increasing/decreasing

<h2>int-enable!</h2>
( f t -- ) 

<h2>interval</h2>
( xt usec t -- ) Setup timer t to call execution token xt after usec - see example below

<h2>levelint!</h2>
( v t -- ) Level trigger

<h2>onalarm</h2>
( xt t -- ) Set callback

<h2>rerun</h2>
( t -- ) Rerun timer t triggering

<h2>t>nx</h2>
( t -- n x ) "x=1 if  bit0 of t=1

<h2>timer!</h2>
( lo hi t -- ) 

<h2>timer@</h2>
( t -- lo hi ) 

<h2>TIMG_BASE</h2>
( -- $3ff5f000 ) constant

<h2>TIMGn</h2>
 

<h2>TIMGn_RTCCALICFG_REG</h2>
( n -- a ) 

<h2>TIMGn_RTCCALICFG1_REG</h2>
( n -- a ) 

<h2>TIMGn_Tx</h2>
( n x -- a ) 

<h2>TIMGn_Tx_INT_CLR_REG</h2>
( n -- a ) 

<h2>TIMGn_Tx_INT_ENA_REG</h2>
( n -- a ) 

<h2>TIMGn_Tx_INT_RAW_REG</h2>
( n -- a ) 

<h2>TIMGn_Tx_INT_ST_REG</h2>
( n -- a ) 

<h2>TIMGn_Tx_WDTCONFIGm_REG</h2>
( n m -- a ) 

<h2>TIMGn_Tx_WDTFEED_REG</h2>
( n -- a ) 

<h2>TIMGn_Tx_WDTWPROTECT_REG</h2>
( n -- a ) 

<h2>TIMGn_TxALARMLOHI_REG</h2>
( n x -- a ) 

<h2>TIMGn_TxCONFIG_REG</h2>
( n x -- a ) 

<h2>TIMGn_TxLOAD_REG</h2>
( n x -- a ) 

<h2>TIMGn_TxLOADLOHI_REG</h2>
( n x -- a ) 

<h2>TIMGn_TxLOHI_REG</h2>
( n x -- a ) 

<h2>TIMGn_TxUPDATE_REG</h2>
( n x -- a ) 

<h2>Two Wire Interface / I2C</h2>
 

<h2>Wire.available</h2>
( -- f ) Returns the number of bytes available for retrieval with Wire.read. This should be called on a master device after a call to Wire.requestFrom

<h2>Wire.begin</h2>
( -- f ) Initiate the Wire library and join the I2C bus as a master. This should normally be called only once.

<h2>Wire.beginTransmission</h2>
( n -- ) "Begin a transmission to the slave device at address n. Subsequently

<h2>Wire.busy</h2>
( -- f ) 

<h2>Wire.endTransmission</h2>
( sendstop -- f ) Ends a transmission to a slave device that was begun by Wire.beginTransmission and transmits the bytes that were queued by Wire.write Sends a stop message if sendstop=true

<h2>Wire.flush</h2>
( -- ) 

<h2>Wire.getClock</h2>
( -- frequency ) Read the clock frequency set by Wire.setClock

<h2>Wire.getErrorText</h2>
( n -- z ) 

<h2>Wire.getTimeout</h2>
( -- ms ) 

<h2>Wire.lastError</h2>
( -- n ) 

<h2>Wire.peek</h2>
( -- ch ) 

<h2>Wire.read</h2>
( -- ch ) Reads a byte that was transmitted from a slave device to a master after a call to Wire.requestFrom or was transmitted from a master to a slave

<h2>Wire.readTransmission</h2>
( addr a n sendstop acount -- err ) 

<h2>Wire.requestFrom</h2>
( address quantity sendstop -- n ) Used to request bytes from a slave device. The bytes may then be retrieved with the Wire.available and Wire.read functions. A stop message is sent after the reqyest if sendstop is true

<h2>Wire.setClock</h2>
( frequency -- ) "Modifies the clock frequency for I2C communication. I2C slave devices have no minimum working clock frequency

<h2>Wire.setTimeout</h2>
( ms -- ) Default is 50ms

<h2>Wire.write</h2>
( a n -- n ) "Writes data from a slave device in response to a request from a master

<h2>Wire.writeTransmission</h2>
( addr a n sendstop -- err ) 

<h2>Vectored execution</h2>
 

<h2>defer</h2>
"( ""vectorname"" -- )" Define a deferred execution vector e.g. defer myemit

<h2>is</h2>
( -- ) Set the vector of a deferred word e.g. ' emit is myemit - sets the deferred word myemit to execute emit when called

<h2>Vocabulary</h2>
 

<h2>}transfer</h2>
 transfer the words enclosed in curly brackets to the current library e.g. { word1 word2 word3 ... }transfer

<h2>also</h2>
( -- ) Duplicate the vocabulary at the top of the vocabulary stack

<h2>context</h2>
( -- a ) an area to specify vocabulary search order - defaults to forth

<h2>definitions</h2>
( -- ) Make the context vocabulary the current vocabulary

<h2>forth</h2>
( -- ) Make the forth vocabulary the current vocabulary

<h2>internals</h2>
 Make the internals vocabulary the current vocabulary

<h2>interrupts</h2>
 Make the interrupts vocabulary the current vocabulary

<h2>ledc</h2>
 Make the ledc vocabulary the current vocabulary

<h2>registers</h2>
( -- ) set the current vocabulary to registers

<h2>rtos</h2>
 Make the rtos vocabulary the current vocabulary

<h2>SD_MMC</h2>
 Make the SD_MMC vocabulary the current vocabulary

<h2>sealed</h2>
( -- ) Alter the last vocabulary defined so it doesn't chain

<h2>Serial</h2>
 Make the Serial vocabulary the current vocabulary

<h2>sockets</h2>
 Make the sockets vocabulary the current vocabulary

<h2>SPIFFS</h2>
 Make the SPIFFS vocabulary the current vocabulary

<h2>streams</h2>
( -- ) set the current vocabulary to streams

<h2>tasks</h2>
 make tasks vocabulary the current one  

<h2>telnetd</h2>
 Make the telnetdvocabulary the current vocabulary

<h2>timers</h2>
( --  ) Make the timers vocabulary the current vocabulary

<h2>vocabulary</h2>
"( ""name"" -- )" Create a vocabulary with the current vocabulary as parent

<h2>web-interface</h2>
 Make the web-interface vocabulary the current vocabulary

<h2>WebServer</h2>
 Make the WebServer vocabulary the current vocabulary

<h1>forth</h1>
<h2>WiFi</h2>
 Make the WiFi vocabulary the current vocabulary

<h2>Wire</h2>
( -- ) Make the Wire vocabulary the current vocabulary

<h2>previous</h2>
( -- ) Drop the vocabulary at the top of the vocabulary stack

<h1> </h1>
<h2>OLED display</h2>
 

<h2> OledInit</h2>
(  --  ) initialize the display to accept commands

<h2> OledDelete </h2>
( n -- a ) 

<h2> OledBegin </h2>
( n -- a ) initialization

<h2> OledHOME </h2>
( n -- a ) send cursor to upper left home position

<h2> OledCLS </h2>
( n -- a ) clears the display

<h2> OledTextc </h2>
( n -- a ) 

<h2> OledPrintln </h2>
( n -- a ) print a zero= null terminated string from the stack 

<h2> OledNumln </h2>
( n -- a ) print + CR   a number on the stack (int)

<h2> OledNum </h2>
( n --  ) print a number on the stack (int)

<h2> OledDisplay </h2>
(  --  ) show the buffer on the OLED display

<h2> OO = Oleddisplay</h2>
( n -- a ) is an abbreviation of Oleddisplay

<h2> OledPrint </h2>
"( z""  ""  addr --  )" print a zero= null terminated string from the stack 

<h2> OledInvert </h2>
(  --  ) invert the background & foreground colors

<h2> OledTextsize </h2>
( n --  ) 

<h2> OledSetCursor </h2>
( n --  ) 

<h2> OledPixel </h2>
( x y C --  ) "draw a pixel    x y coordinates  C= Color 

<h2> OledDrawL </h2>
( x y x2 y2 1  --  ) "draw a line  x y x2 y2 coordinates  C= Color 

<h2> OledCirc </h2>
( x y r 1  --  ) draw a circle

<h2> OledCircF </h2>
( x y r 1  --  ) draw a circle filled

<h2> OledRect </h2>
( x y x2 y2 1  --  ) draw a rectangle

<h2> OledRectF </h2>
( x y x2 y2 1  --  ) draw a rectangle filled

<h2> OledRectR </h2>
( x y x2 y2 1  --  ) draw a rectangle rounded edges

<h2> OledRectRF </h2>
( n -- a ) draw a rectangle rounded edges filled

<h2> OledAddr </h2>
( n -- a ) address of I2C device

<h2> OledNew </h2>
( n -- a ) 

<h2>Web Interface</h2>
 

<h2>do-serve</h2>
 

<h2>handle-index</h2>
 

<h2>handle-input</h2>
 

<h2>handle1</h2>
 

<h2>index-html</h2>
 

<h2>input-stream</h2>
 

<h2>out-size</h2>
 

<h2>out-string</h2>
 

<h2>output-stream</h2>
 

<h2>serve-key</h2>
 

<h2>serve-type</h2>
 

<h2>webserver</h2>
 

<h2>webserver-task</h2>
 

<h2>Web Server</h2>
 

<h2>WebServer.arg</h2>
( z ws -- z ) By name

<h2>WebServer.argi</h2>
( n ws -- z ) By index

<h2>WebServer.argName</h2>
( n ws -- z) By index

<h2>WebServer.args</h2>
By index Number of args

<h2>WebServer.begin</h2>
( port ws -- ) 

<h2>WebServer.delete</h2>
( ws -- ) Delete webserver object

<h2>WebServer.handleClient</h2>
( ws -- ) Handle one client request

<h2>WebServer.hasArg</h2>
( z ws -- f ) By name

<h2>WebServer.method</h2>
( ws -- n ) GET / POST etc.

<h2>WebServer.new</h2>
( port -- ws ) Allocate new webserver object

<h2>WebServer.on</h2>
( path-z xt ws -- ) Set up a web path handle callback

<h2>WebServer.send</h2>
( code mimetype data ws -- ) 

<h2>WebServer.sendContent</h2>
( z ws -- ) 

<h2>WebServer.sendHeader</h2>
( name-z value-z fist ws -- ) 

<h2>WebServer.setContentLength</h2>
( n ws -- ) 

<h2>WebServer.stop</h2>
( ws -- ) 

<h2>WiFi</h2>
 

<h2>login</h2>
( network-z password-z -- ) "login to wifi only e.g. z"" NETWORK-NAME"" z"" PASSWORD""  login"

<h2>WIFI_MODE_AP</h2>
( -- 2 ) access point mode: stations can connect to the ESP32 e.g. WIFI_MODE_AP WiFi.mode

<h2>WIFI_MODE_APSTA</h2>
( -- 3 ) access point and a station connected to another access point e.g. WIFI_MODE_APSTA WiFi.mode

<h2>WIFI_MODE_NULL</h2>
( -- 0 ) 

<h2>WIFI_MODE_STA</h2>
( -- 1 ) station mode: the ESP32 connects to an access point e.g WIFI_MODE_STA WiFi.mode

<h2>WiFi.begin</h2>
( ssid-z password-z -- ) "Initializes the WiFi library's network settings and provides the current status. e.g. z"" mySSID"" z"" myPASSWORD"" WiFi.begin -- see connection-disconnection demo below"

<h2>WiFi.config</h2>
( ip dns gateway subnet -- ) "Allows you to configure a static IP address as well as change the DNS

<h2>WiFi.disconnect</h2>
( -- ) Disconnects the WiFi shield from the current network

<h2>WiFi.getTxPower</h2>
( -- powerx4 ) Get power x4

<h2>WiFi.localIP</h2>
( -- ip ) Get local IP

<h2>WiFi.macAddress</h2>
( a -- ) Gets the MAC Address of your ESP32 WiFi port

<h2>WiFi.mode</h2>
( mode -- ) Set WiFi mode - see notes below

<h2>WiFi.setTxPower</h2>
( powerx4 -- ) Set power x4

<h2>WiFi.status</h2>
( -- n ) Returns the connection status - see notes below

<h2>Word definitions</h2>
 

<h2>"</h2>
" ( n -- )

<h2>;</h2>
(  -- ) "stop compiler

<h2>:</h2>
"( ""wordname"" --  )" "start compiler mode

<h2>:noname</h2>
( – xt ) "Create a word with no name

<h2>'</h2>
"( ""wordname"" -- xt )" "xt = execution token of the word that follows in the input stream e.g. ' words puts 1073654684 on the stack. Errors if word not found

<h2>[</h2>
( -- ) stop compiling the input stream and start executing - sets state=true

<h2>[']</h2>
( -- xt ) xt = execution of the word that follows inside a : definition e.g. : COMING   ['] HELLO   'aloha ! ;

<h2>]</h2>
( -- ) "Stop executing and start compiling the input stream

<h2>{</h2>
( -- ) Mark the start of a local variable block - see example below

<h2>align</h2>
 

<h2>aligned</h2>
( addr1 -- addr2 ) "converts an address on the stack to the next higher cell boundary

<h2>allot</h2>
B286 "see ""allocate""   B286"

<h2>"c</h2>
" ( c -- )

<h2>constant</h2>
"( n ""name"" -- )" "create a constant whose name follws in the input stream

<h2>CREATE</h2>
( -- ; -- pfa ) "create an empty dictionary entry <name>

<h1>forth</h1>
<h2>IMMEDIATE</h2>
 Marks the last defined word as immediate - it will execute immediately if called whilst compiling a word

<h2>literal</h2>
( n -- ; -- n ) "add top of stack into the word being compiled at the next free memory location. When the word is run

<h2>postpone</h2>
"( ""text"" -- )" Skip leading space delimiters. Parse name delimited by a space. Find name. Append the compilation semantics of name to the current definition. Useful when an immediate word needs to be compiled in a word definition instead of immediately executing

<h1>forth</h1>
<h2>SMUDGE</h2>
( -- ) stops the current word being defined being found during a dictionary lookup

<h2>value</h2>
"( n ""valname"" -- ; -- n )" "creates a value

<h2>variable</h2>
"( ""varname"" -- ; -- addr  )" variable takes the next word in the input stream as the name and reserves space  for a variable

<h2>Orphan words - yet to be allocated</h2>
 

<h2>MDNS.begin</h2>
( name-z -- ) Start multicast dns

<h2>refill</h2>
 

<h2>vTaskDelete</h2>
( task -- ) 

<h2>xPortGetCoreID</h2>
( -- n ) 

<h2>xTaskCreatePinnedToCore</h2>
( fn name stack-depth params priority taskout coreid -- ) 

<h2>FLOATING POINT WORDS --(Requires v7.0.6.5+) </h2>
 

<h1>Single precision floating-point support is available as a work in progress. </h1>
<h1>Floating point is kept on a separate stack.</h1>
<h1>NOTE: Tasks currently don't correctly support floating point. A single floating point stack is shared by all tasks.</h1>
<h1>FP@ ( -- a )</h1>
<h1>FP! ( a -- )</h1>
<h1>FDUP ( r -- r r )</h1>
<h1>FNIP ( ra rb -- rb )</h1>
<h1>FDROP ( r -- )</h1>
<h1>FOVER ( ra rb -- ra rb ra )</h1>
<h1>FSWAP ( ra rb -- rb ra )</h1>
<h1>F0< ( r -- f )</h1>
<h1>F0= ( r -- f )</h1>
<h1>F+ ( r r -- r )</h1>
<h1>F- ( r r -- r )</h1>
<h1>F* ( r r -- r )</h1>
<h1>F/ ( r r -- r )</h1>
<h1>1/F ( r -- r )</h1>
<h1>S>F ( n -- r )</h1>
<h1>F>S ( r -- n )</h1>
<h1>HIGH LEVEL</h1>
<h1>----------</h1>
<h1>F= ( r r -- f )</h1>
<h1>F< ( r r -- f )</h1>
<h1>F> ( r r -- f )</h1>
<h1>F<= ( r r -- f )</h1>
<h1>F>= ( r r -- f )</h1>
<h1>F<> ( r r -- f )</h1>
<h1>SFLOAT ( -- 4 )</h1>
<h1>SFLOATS ( n -- n*4 )</h1>
<h1>SFLOAT+ ( a -- a+4 )</h1>
<h1>AFLITERAL ( r -- )</h1>
<h1>FLITERAL ( r -- ) IMMEDIATE</h1>
<h1>"FCONSTANT ( r ""name"" )"</h1>
<h1>"FVARIABLE ( ""name"" )"</h1>
<h1>PI ( -- r )</h1>
<h1>FSQRT ( r r -- r )</h1>
<h2>F.  </h2>
( n-- ) "Display

<h2>Serial Bluetooth WORDS --(Requires v7.0.6.5+) </h2>
 

<h1>Bluetooth</h1>
<h1>These words are inside the bluetooth vocabulary.</h1>
<h1>esp_bt_dev_get_address ( -- a ) addr of 6 byte mac address</h1>
<h1>Serial Bluetooth</h1>
<h1>These words are inside the bluetooth vocabulary.</h1>
<h1>SerialBT.new ( -- bt )   Allocate new BT object</h1>
<h1>SerialBT.delete ( bt -- )   Free BT object</h1>
<h1>SerialBT.begin ( localname ismaster bt -- f )</h1>
<h1>SerialBT.end ( bt -- )</h1>
<h1>SerialBT.available ( bt -- f )</h1>
<h1>SerialBT.readBytes ( a n bt -- n )</h1>
<h1>SerialBT.write ( a n bt -- n )</h1>
<h1>SerialBT.flush ( bt -- )</h1>
<h1>SerialBT.hasClient ( bt -- f )</h1>
<h1>SerialBT.enableSSP ( bt -- )</h1>
<h1>SerialBT.setPin ( z bt -- f )</h1>
<h1>SerialBT.unpairDevice ( addr bt -- f )</h1>
<h1>SerialBT.connect ( remotename bt -- f )</h1>
<h1>SerialBT.connectAddr ( addr bt -- f )</h1>
<h1>SerialBT.disconnect ( bt -- f )</h1>
<h1>SerialBT.connected ( timeout bt -- f )</h1>
<h2>Camera WORDS --(Requires v7.0.6.5+) </h2>
 

<h1>Camera</h1>
<h1>These words are inside the camera vocabulary.</h1>
<h1>esp_camera_init ( config -- f )</h1>
<h1>esp_camera_deinit ( -- f )</h1>
<h1>esp_camera_fb_get ( -- fb )</h1>
<h1>esp_camera_fb_return ( fb -- )</h1>
<h1>esp_camera_sensor_get ( -- sensor )</h1>
<h2>Camera Server WORDS --(Requires v7.0.6.5+) </